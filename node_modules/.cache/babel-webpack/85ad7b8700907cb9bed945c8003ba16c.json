{"ast":null,"code":"import _slicedToArray from \"/home/danielbertoni/angular/tktadmin/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createClass from \"/home/danielbertoni/angular/tktadmin/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/home/danielbertoni/angular/tktadmin/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { Subject, merge } from 'rxjs';\nimport { Directive, ElementRef, Renderer2, Output, EventEmitter, Input, NgZone, NgModule } from '@angular/core';\nimport { map, mergeMap, takeUntil, take, takeLast, pairwise, share, filter, distinctUntilChanged } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nvar DraggableHelper = function DraggableHelper() {\n  _classCallCheck(this, DraggableHelper);\n\n  this.currentDrag = new Subject();\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar\n/** @type {?} */\nMOVE_CURSOR = 'move';\n\nvar DraggableDirective = /*#__PURE__*/function () {\n  /**\n   * @hidden\n   * @param {?} element\n   * @param {?} renderer\n   * @param {?} draggableHelper\n   * @param {?} zone\n   */\n  function DraggableDirective(element, renderer, draggableHelper, zone) {\n    _classCallCheck(this, DraggableDirective);\n\n    this.element = element;\n    this.renderer = renderer;\n    this.draggableHelper = draggableHelper;\n    this.zone = zone;\n    /**\n     * The axis along which the element is draggable\n     */\n\n    this.dragAxis = {\n      x: true,\n      y: true\n    };\n    /**\n     * Snap all drags to an x / y grid\n     */\n\n    this.dragSnapGrid = {};\n    /**\n     * Show a ghost element that shows the drag when dragging\n     */\n\n    this.ghostDragEnabled = true;\n    /**\n     * The cursor to use when dragging the element\n     */\n\n    this.dragCursor = MOVE_CURSOR;\n    /**\n     * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n     */\n\n    this.dragPointerDown = new EventEmitter();\n    /**\n     * Called when the element has started to be dragged.\n     * Only called after at least one mouse or touch move event\n     */\n\n    this.dragStart = new EventEmitter();\n    /**\n     * Called when the element is being dragged\n     */\n\n    this.dragging = new EventEmitter();\n    /**\n     * Called after the element is dragged\n     */\n\n    this.dragEnd = new EventEmitter();\n    /**\n     * @hidden\n     */\n\n    this.pointerDown = new Subject();\n    /**\n     * @hidden\n     */\n\n    this.pointerMove = new Subject();\n    /**\n     * @hidden\n     */\n\n    this.pointerUp = new Subject();\n    this.eventListenerSubscriptions = {};\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(DraggableDirective, [{\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      var _this = this;\n\n      this.checkEventListeners();\n      var\n      /** @type {?} */\n      pointerDrag = this.pointerDown.pipe(filter(function () {\n        return _this.canDrag();\n      })).pipe(mergeMap(function (pointerDownEvent) {\n        var\n        /** @type {?} */\n        currentDrag = new Subject();\n\n        _this.zone.run(function () {\n          _this.dragPointerDown.next({\n            x: 0,\n            y: 0\n          });\n        });\n\n        var\n        /** @type {?} */\n        pointerMove = _this.pointerMove.pipe(map(function (pointerMoveEvent) {\n          pointerMoveEvent.event.preventDefault();\n          return {\n            currentDrag: currentDrag,\n            x: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n            y: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n            clientX: pointerMoveEvent.clientX,\n            clientY: pointerMoveEvent.clientY\n          };\n        })).pipe(map(function (moveData) {\n          if (_this.dragSnapGrid.x) {\n            moveData.x = Math.floor(moveData.x / _this.dragSnapGrid.x) * _this.dragSnapGrid.x;\n          }\n\n          if (_this.dragSnapGrid.y) {\n            moveData.y = Math.floor(moveData.y / _this.dragSnapGrid.y) * _this.dragSnapGrid.y;\n          }\n\n          return moveData;\n        })).pipe(map(function (moveData) {\n          if (!_this.dragAxis.x) {\n            moveData.x = 0;\n          }\n\n          if (!_this.dragAxis.y) {\n            moveData.y = 0;\n          }\n\n          return moveData;\n        })).pipe(filter(function (_ref) {\n          var x = _ref.x,\n              y = _ref.y;\n          return !_this.validateDrag || _this.validateDrag({\n            x: x,\n            y: y\n          });\n        })).pipe(takeUntil(merge(_this.pointerUp, _this.pointerDown))).pipe(share());\n\n        pointerMove.pipe(take(1)).subscribe(function () {\n          pointerDownEvent.event.preventDefault();\n\n          _this.zone.run(function () {\n            _this.dragStart.next({\n              x: 0,\n              y: 0\n            });\n          });\n\n          _this.setCursor(_this.dragCursor);\n\n          _this.draggableHelper.currentDrag.next(currentDrag);\n        });\n        pointerMove.pipe(takeLast(1)).subscribe(function (_ref2) {\n          var x = _ref2.x,\n              y = _ref2.y;\n\n          _this.zone.run(function () {\n            _this.dragEnd.next({\n              x: x,\n              y: y\n            });\n          });\n\n          currentDrag.complete();\n\n          _this.setCssTransform('');\n\n          if (_this.ghostDragEnabled) {\n            _this.renderer.setStyle(_this.element.nativeElement, 'pointerEvents', '');\n          }\n        });\n        return pointerMove;\n      })).pipe(share());\n      merge(pointerDrag.pipe(take(1)).pipe(map(function (value) {\n        return [, value];\n      })), pointerDrag.pipe(pairwise())).pipe(filter(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            previous = _ref4[0],\n            next = _ref4[1];\n\n        if (!previous) {\n          return true;\n        }\n\n        return previous.x !== next.x || previous.y !== next.y;\n      })).pipe(map(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            previous = _ref6[0],\n            next = _ref6[1];\n\n        return next;\n      })).subscribe(function (_ref7) {\n        var x = _ref7.x,\n            y = _ref7.y,\n            currentDrag = _ref7.currentDrag,\n            clientX = _ref7.clientX,\n            clientY = _ref7.clientY;\n\n        _this.zone.run(function () {\n          _this.dragging.next({\n            x: x,\n            y: y\n          });\n        });\n\n        if (_this.ghostDragEnabled) {\n          _this.renderer.setStyle(_this.element.nativeElement, 'pointerEvents', 'none');\n        }\n\n        _this.setCssTransform(\"translate(\".concat(x, \"px, \").concat(y, \"px)\"));\n\n        currentDrag.next({\n          clientX: clientX,\n          clientY: clientY,\n          dropData: _this.dropData\n        });\n      });\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnChanges\",\n    value: function ngOnChanges(changes) {\n      if (changes['dragAxis']) {\n        this.checkEventListeners();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.unsubscribeEventListeners();\n      this.pointerDown.complete();\n      this.pointerMove.complete();\n      this.pointerUp.complete();\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"checkEventListeners\",\n    value: function checkEventListeners() {\n      var _this2 = this;\n\n      var\n      /** @type {?} */\n      canDrag = this.canDrag();\n      var\n      /** @type {?} */\n      hasEventListeners = Object.keys(this.eventListenerSubscriptions).length > 0;\n\n      if (canDrag && !hasEventListeners) {\n        this.zone.runOutsideAngular(function () {\n          _this2.eventListenerSubscriptions.mousedown = _this2.renderer.listen(_this2.element.nativeElement, 'mousedown', function (event) {\n            _this2.onMouseDown(event);\n          });\n          _this2.eventListenerSubscriptions.mouseup = _this2.renderer.listen('document', 'mouseup', function (event) {\n            _this2.onMouseUp(event);\n          });\n          _this2.eventListenerSubscriptions.touchstart = _this2.renderer.listen(_this2.element.nativeElement, 'touchstart', function (event) {\n            _this2.onTouchStart(event);\n          });\n          _this2.eventListenerSubscriptions.touchend = _this2.renderer.listen('document', 'touchend', function (event) {\n            _this2.onTouchEnd(event);\n          });\n          _this2.eventListenerSubscriptions.touchcancel = _this2.renderer.listen('document', 'touchcancel', function (event) {\n            _this2.onTouchEnd(event);\n          });\n          _this2.eventListenerSubscriptions.mouseenter = _this2.renderer.listen(_this2.element.nativeElement, 'mouseenter', function () {\n            _this2.onMouseEnter();\n          });\n          _this2.eventListenerSubscriptions.mouseleave = _this2.renderer.listen(_this2.element.nativeElement, 'mouseleave', function () {\n            _this2.onMouseLeave();\n          });\n        });\n      } else if (!canDrag && hasEventListeners) {\n        this.unsubscribeEventListeners();\n      }\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onMouseDown\",\n    value: function onMouseDown(event) {\n      var _this3 = this;\n\n      if (!this.eventListenerSubscriptions.mousemove) {\n        this.eventListenerSubscriptions.mousemove = this.renderer.listen('document', 'mousemove', function (mouseMoveEvent) {\n          _this3.pointerMove.next({\n            event: mouseMoveEvent,\n            clientX: mouseMoveEvent.clientX,\n            clientY: mouseMoveEvent.clientY\n          });\n        });\n      }\n\n      this.pointerDown.next({\n        event: event,\n        clientX: event.clientX,\n        clientY: event.clientY\n      });\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp(event) {\n      if (this.eventListenerSubscriptions.mousemove) {\n        this.eventListenerSubscriptions.mousemove();\n        delete this.eventListenerSubscriptions.mousemove;\n      }\n\n      this.pointerUp.next({\n        event: event,\n        clientX: event.clientX,\n        clientY: event.clientY\n      });\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onTouchStart\",\n    value: function onTouchStart(event) {\n      var _this4 = this;\n\n      if (!this.eventListenerSubscriptions.touchmove) {\n        this.eventListenerSubscriptions.touchmove = this.renderer.listen('document', 'touchmove', function (touchMoveEvent) {\n          _this4.pointerMove.next({\n            event: touchMoveEvent,\n            clientX: touchMoveEvent.targetTouches[0].clientX,\n            clientY: touchMoveEvent.targetTouches[0].clientY\n          });\n        });\n      }\n\n      this.pointerDown.next({\n        event: event,\n        clientX: event.touches[0].clientX,\n        clientY: event.touches[0].clientY\n      });\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onTouchEnd\",\n    value: function onTouchEnd(event) {\n      if (this.eventListenerSubscriptions.touchmove) {\n        this.eventListenerSubscriptions.touchmove();\n        delete this.eventListenerSubscriptions.touchmove;\n      }\n\n      this.pointerUp.next({\n        event: event,\n        clientX: event.changedTouches[0].clientX,\n        clientY: event.changedTouches[0].clientY\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"onMouseEnter\",\n    value: function onMouseEnter() {\n      this.setCursor(this.dragCursor);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"onMouseLeave\",\n    value: function onMouseLeave() {\n      this.setCursor('');\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n  }, {\n    key: \"setCssTransform\",\n    value: function setCssTransform(value) {\n      var _this5 = this;\n\n      if (this.ghostDragEnabled) {\n        var\n        /** @type {?} */\n        transformAttributes = ['transform', '-webkit-transform', '-ms-transform', '-moz-transform', '-o-transform'];\n        transformAttributes.forEach(function (transformAttribute) {\n          _this5.renderer.setStyle(_this5.element.nativeElement, transformAttribute, value);\n        });\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"canDrag\",\n    value: function canDrag() {\n      return this.dragAxis.x || this.dragAxis.y;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n  }, {\n    key: \"setCursor\",\n    value: function setCursor(value) {\n      this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"unsubscribeEventListeners\",\n    value: function unsubscribeEventListeners() {\n      var _this6 = this;\n\n      Object.keys(this.eventListenerSubscriptions).forEach(function (type) {\n        /** @type {?} */\n        _this6.eventListenerSubscriptions[type]();\n\n        delete\n        /** @type {?} */\n        _this6.eventListenerSubscriptions[type];\n      });\n    }\n  }]);\n\n  return DraggableDirective;\n}();\n\nDraggableDirective.ɵfac = function DraggableDirective_Factory(t) {\n  return new (t || DraggableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DraggableHelper), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n};\n\nDraggableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: DraggableDirective,\n  selectors: [[\"\", \"mwlDraggable\", \"\"]],\n  inputs: {\n    dragAxis: \"dragAxis\",\n    dragSnapGrid: \"dragSnapGrid\",\n    ghostDragEnabled: \"ghostDragEnabled\",\n    dragCursor: \"dragCursor\",\n    dropData: \"dropData\",\n    validateDrag: \"validateDrag\"\n  },\n  outputs: {\n    dragPointerDown: \"dragPointerDown\",\n    dragStart: \"dragStart\",\n    dragging: \"dragging\",\n    dragEnd: \"dragEnd\"\n  },\n  features: [ɵngcc0.ɵɵNgOnChangesFeature]\n});\n/** @nocollapse */\n\nDraggableDirective.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: Renderer2\n  }, {\n    type: DraggableHelper\n  }, {\n    type: NgZone\n  }];\n};\n\nDraggableDirective.propDecorators = {\n  \"dropData\": [{\n    type: Input\n  }],\n  \"dragAxis\": [{\n    type: Input\n  }],\n  \"dragSnapGrid\": [{\n    type: Input\n  }],\n  \"ghostDragEnabled\": [{\n    type: Input\n  }],\n  \"validateDrag\": [{\n    type: Input\n  }],\n  \"dragCursor\": [{\n    type: Input\n  }],\n  \"dragPointerDown\": [{\n    type: Output\n  }],\n  \"dragStart\": [{\n    type: Output\n  }],\n  \"dragging\": [{\n    type: Output\n  }],\n  \"dragEnd\": [{\n    type: Output\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DraggableDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDraggable]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.Renderer2\n    }, {\n      type: DraggableHelper\n    }, {\n      type: ɵngcc0.NgZone\n    }];\n  }, {\n    dragAxis: [{\n      type: Input\n    }],\n    dragSnapGrid: [{\n      type: Input\n    }],\n    ghostDragEnabled: [{\n      type: Input\n    }],\n    dragCursor: [{\n      type: Input\n    }],\n    dragPointerDown: [{\n      type: Output\n    }],\n    dragStart: [{\n      type: Output\n    }],\n    dragging: [{\n      type: Output\n    }],\n    dragEnd: [{\n      type: Output\n    }],\n    dropData: [{\n      type: Input\n    }],\n    validateDrag: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @param {?} clientX\n * @param {?} clientY\n * @param {?} rect\n * @return {?}\n */\n\n\nfunction isCoordinateWithinRectangle(clientX, clientY, rect) {\n  return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n}\n\nvar DroppableDirective = /*#__PURE__*/function () {\n  /**\n   * @param {?} element\n   * @param {?} draggableHelper\n   * @param {?} zone\n   */\n  function DroppableDirective(element, draggableHelper, zone) {\n    _classCallCheck(this, DroppableDirective);\n\n    this.element = element;\n    this.draggableHelper = draggableHelper;\n    this.zone = zone;\n    /**\n     * Called when a draggable element starts overlapping the element\n     */\n\n    this.dragEnter = new EventEmitter();\n    /**\n     * Called when a draggable element stops overlapping the element\n     */\n\n    this.dragLeave = new EventEmitter();\n    /**\n     * Called when a draggable element is moved over the element\n     */\n\n    this.dragOver = new EventEmitter();\n    /**\n     * Called when a draggable element is dropped on this element\n     */\n\n    this.drop = new EventEmitter();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(DroppableDirective, [{\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      var _this7 = this;\n\n      this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe(function (drag) {\n        var\n        /** @type {?} */\n        droppableRectangle = _this7.element.nativeElement.getBoundingClientRect();\n\n        var\n        /** @type {?} */\n        currentDragDropData;\n        var\n        /** @type {?} */\n        overlaps = drag.pipe(map(function (_ref8) {\n          var clientX = _ref8.clientX,\n              clientY = _ref8.clientY,\n              dropData = _ref8.dropData;\n          currentDragDropData = dropData;\n          return isCoordinateWithinRectangle(clientX, clientY, droppableRectangle);\n        }));\n        var\n        /** @type {?} */\n        overlapsChanged = overlaps.pipe(distinctUntilChanged());\n        var\n        /** @type {?} */\n        dragOverActive; // TODO - see if there's a way of doing this via rxjs\n\n        overlapsChanged.pipe(filter(function (overlapsNow) {\n          return overlapsNow;\n        })).subscribe(function () {\n          dragOverActive = true;\n\n          _this7.zone.run(function () {\n            _this7.dragEnter.next({\n              dropData: currentDragDropData\n            });\n          });\n        });\n        overlaps.pipe(filter(function (overlapsNow) {\n          return overlapsNow;\n        })).subscribe(function () {\n          _this7.zone.run(function () {\n            _this7.dragOver.next({\n              dropData: currentDragDropData\n            });\n          });\n        });\n        overlapsChanged.pipe(pairwise()).pipe(filter(function (_ref9) {\n          var _ref10 = _slicedToArray(_ref9, 2),\n              didOverlap = _ref10[0],\n              overlapsNow = _ref10[1];\n\n          return didOverlap && !overlapsNow;\n        })).subscribe(function () {\n          dragOverActive = false;\n\n          _this7.zone.run(function () {\n            _this7.dragLeave.next({\n              dropData: currentDragDropData\n            });\n          });\n        });\n        drag.pipe(mergeMap(function () {\n          return overlaps;\n        })).subscribe({\n          complete: function complete() {\n            if (dragOverActive) {\n              _this7.zone.run(function () {\n                _this7.drop.next({\n                  dropData: currentDragDropData\n                });\n              });\n            }\n          }\n        });\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.currentDragSubscription.unsubscribe();\n    }\n  }]);\n\n  return DroppableDirective;\n}();\n\nDroppableDirective.ɵfac = function DroppableDirective_Factory(t) {\n  return new (t || DroppableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DraggableHelper), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n};\n\nDroppableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: DroppableDirective,\n  selectors: [[\"\", \"mwlDroppable\", \"\"]],\n  outputs: {\n    dragEnter: \"dragEnter\",\n    dragLeave: \"dragLeave\",\n    dragOver: \"dragOver\",\n    drop: \"drop\"\n  }\n});\n/** @nocollapse */\n\nDroppableDirective.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: DraggableHelper\n  }, {\n    type: NgZone\n  }];\n};\n\nDroppableDirective.propDecorators = {\n  \"dragEnter\": [{\n    type: Output\n  }],\n  \"dragLeave\": [{\n    type: Output\n  }],\n  \"dragOver\": [{\n    type: Output\n  }],\n  \"drop\": [{\n    type: Output\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DroppableDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDroppable]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: DraggableHelper\n    }, {\n      type: ɵngcc0.NgZone\n    }];\n  }, {\n    dragEnter: [{\n      type: Output\n    }],\n    dragLeave: [{\n      type: Output\n    }],\n    dragOver: [{\n      type: Output\n    }],\n    drop: [{\n      type: Output\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar DragAndDropModule = /*#__PURE__*/function () {\n  function DragAndDropModule() {\n    _classCallCheck(this, DragAndDropModule);\n  }\n\n  _createClass(DragAndDropModule, null, [{\n    key: \"forRoot\",\n    value:\n    /**\n     * @return {?}\n     */\n    function forRoot() {\n      return {\n        ngModule: DragAndDropModule,\n        providers: [DraggableHelper]\n      };\n    }\n  }]);\n\n  return DragAndDropModule;\n}();\n\nDragAndDropModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: DragAndDropModule\n});\nDragAndDropModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function DragAndDropModule_Factory(t) {\n    return new (t || DragAndDropModule)();\n  }\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DragAndDropModule, {\n    declarations: [DraggableDirective, DroppableDirective],\n    exports: [DraggableDirective, DroppableDirective]\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragAndDropModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [DraggableDirective, DroppableDirective],\n      exports: [DraggableDirective, DroppableDirective]\n    }]\n  }], null, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nexport { DragAndDropModule, DraggableHelper, DraggableDirective as ɵa, DroppableDirective as ɵb };","map":{"version":3,"sources":["angular-draggable-droppable/draggable-helper.provider.ts","angular-draggable-droppable/draggable.directive.ts","angular-draggable-droppable/droppable.directive.ts","angular-draggable-droppable/drag-and-drop.module.ts"],"names":[],"mappings":"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","sourcesContent":["import { Subject } from 'rxjs';\n\nexport class DraggableHelper {\n  currentDrag: Subject<any> = new Subject();\n}\n","import {\n  Directive,\n  OnInit,\n  ElementRef,\n  Renderer2,\n  Output,\n  EventEmitter,\n  Input,\n  OnDestroy,\n  OnChanges,\n  NgZone,\n  SimpleChanges\n} from '@angular/core';\nimport { Subject, Observable, merge } from 'rxjs';\nimport {\n  map,\n  mergeMap,\n  takeUntil,\n  take,\n  takeLast,\n  pairwise,\n  share,\n  filter\n} from 'rxjs/operators';\nimport { DraggableHelper } from './draggable-helper.provider';\n\nexport interface Coordinates {\n  x: number;\n  y: number;\n}\n\nexport interface DragAxis {\n  x: boolean;\n  y: boolean;\n}\n\nexport interface SnapGrid {\n  x?: number;\n  y?: number;\n}\n\nexport type ValidateDrag = (coordinates: Coordinates) => boolean;\n\nexport interface PointerEvent {\n  clientX: number;\n  clientY: number;\n  event: MouseEvent | TouchEvent;\n}\n\nconst MOVE_CURSOR: string = 'move';\n\n@Directive({\n  selector: '[mwlDraggable]'\n})\nexport class DraggableDirective implements OnInit, OnChanges, OnDestroy {\n  /**\n   * an object of data you can pass to the drop event\n   */\n  @Input() dropData: any;\n\n  /**\n   * The axis along which the element is draggable\n   */\n  @Input() dragAxis: DragAxis = { x: true, y: true };\n\n  /**\n   * Snap all drags to an x / y grid\n   */\n  @Input() dragSnapGrid: SnapGrid = {};\n\n  /**\n   * Show a ghost element that shows the drag when dragging\n   */\n  @Input() ghostDragEnabled: boolean = true;\n\n  /**\n   * Allow custom behaviour to control when the element is dragged\n   */\n  @Input() validateDrag: ValidateDrag;\n\n  /**\n   * The cursor to use when dragging the element\n   */\n  @Input() dragCursor = MOVE_CURSOR;\n\n  /**\n   * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n   */\n  @Output() dragPointerDown = new EventEmitter<Coordinates>();\n\n  /**\n   * Called when the element has started to be dragged.\n   * Only called after at least one mouse or touch move event\n   */\n  @Output() dragStart = new EventEmitter<Coordinates>();\n\n  /**\n   * Called when the element is being dragged\n   */\n  @Output() dragging = new EventEmitter<Coordinates>();\n\n  /**\n   * Called after the element is dragged\n   */\n  @Output() dragEnd = new EventEmitter<Coordinates>();\n\n  /**\n   * @hidden\n   */\n  pointerDown: Subject<PointerEvent> = new Subject();\n\n  /**\n   * @hidden\n   */\n  pointerMove: Subject<PointerEvent> = new Subject();\n\n  /**\n   * @hidden\n   */\n  pointerUp: Subject<PointerEvent> = new Subject();\n\n  private eventListenerSubscriptions: {\n    mousemove?: () => void;\n    mousedown?: () => void;\n    mouseup?: () => void;\n    mouseenter?: () => void;\n    mouseleave?: () => void;\n    touchstart?: () => void;\n    touchmove?: () => void;\n    touchend?: () => void;\n    touchcancel?: () => void;\n  } = {};\n\n  /**\n   * @hidden\n   */\n  constructor(\n    public element: ElementRef,\n    private renderer: Renderer2,\n    private draggableHelper: DraggableHelper,\n    private zone: NgZone\n  ) {}\n\n  ngOnInit(): void {\n    this.checkEventListeners();\n\n    const pointerDrag: Observable<any> = this.pointerDown\n      .pipe(filter(() => this.canDrag()))\n      .pipe(\n        mergeMap((pointerDownEvent: PointerEvent) => {\n          const currentDrag: Subject<any> = new Subject();\n\n          this.zone.run(() => {\n            this.dragPointerDown.next({ x: 0, y: 0 });\n          });\n\n          const pointerMove: Observable<Coordinates> = this.pointerMove\n            .pipe(\n              map((pointerMoveEvent: PointerEvent) => {\n                pointerMoveEvent.event.preventDefault();\n\n                return {\n                  currentDrag,\n                  x: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n                  y: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n                  clientX: pointerMoveEvent.clientX,\n                  clientY: pointerMoveEvent.clientY\n                };\n              })\n            )\n            .pipe(\n              map((moveData: Coordinates) => {\n                if (this.dragSnapGrid.x) {\n                  moveData.x =\n                    Math.floor(moveData.x / this.dragSnapGrid.x) *\n                    this.dragSnapGrid.x;\n                }\n\n                if (this.dragSnapGrid.y) {\n                  moveData.y =\n                    Math.floor(moveData.y / this.dragSnapGrid.y) *\n                    this.dragSnapGrid.y;\n                }\n\n                return moveData;\n              })\n            )\n            .pipe(\n              map((moveData: Coordinates) => {\n                if (!this.dragAxis.x) {\n                  moveData.x = 0;\n                }\n\n                if (!this.dragAxis.y) {\n                  moveData.y = 0;\n                }\n\n                return moveData;\n              })\n            )\n            .pipe(\n              filter(\n                ({ x, y }) => !this.validateDrag || this.validateDrag({ x, y })\n              )\n            )\n            .pipe(takeUntil(merge(this.pointerUp, this.pointerDown)))\n            .pipe(share());\n\n          pointerMove.pipe(take(1)).subscribe(() => {\n            pointerDownEvent.event.preventDefault();\n\n            this.zone.run(() => {\n              this.dragStart.next({ x: 0, y: 0 });\n            });\n\n            this.setCursor(this.dragCursor);\n\n            this.draggableHelper.currentDrag.next(currentDrag);\n          });\n\n          pointerMove.pipe(takeLast(1)).subscribe(({ x, y }) => {\n            this.zone.run(() => {\n              this.dragEnd.next({ x, y });\n            });\n            currentDrag.complete();\n            this.setCssTransform('');\n            if (this.ghostDragEnabled) {\n              this.renderer.setStyle(\n                this.element.nativeElement,\n                'pointerEvents',\n                ''\n              );\n            }\n          });\n\n          return pointerMove;\n        })\n      )\n      .pipe(share());\n\n    merge(\n      pointerDrag.pipe(take(1)).pipe(map(value => [, value])),\n      pointerDrag.pipe(pairwise())\n    )\n      .pipe(\n        filter(([previous, next]) => {\n          if (!previous) {\n            return true;\n          }\n          return previous.x !== next.x || previous.y !== next.y;\n        })\n      )\n      .pipe(map(([previous, next]) => next))\n      .subscribe(({ x, y, currentDrag, clientX, clientY }) => {\n        this.zone.run(() => {\n          this.dragging.next({ x, y });\n        });\n        if (this.ghostDragEnabled) {\n          this.renderer.setStyle(\n            this.element.nativeElement,\n            'pointerEvents',\n            'none'\n          );\n        }\n        this.setCssTransform(`translate(${x}px, ${y}px)`);\n        currentDrag.next({\n          clientX,\n          clientY,\n          dropData: this.dropData\n        });\n      });\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes['dragAxis']) {\n      this.checkEventListeners();\n    }\n  }\n\n  ngOnDestroy(): void {\n    this.unsubscribeEventListeners();\n    this.pointerDown.complete();\n    this.pointerMove.complete();\n    this.pointerUp.complete();\n  }\n\n  private checkEventListeners(): void {\n    const canDrag: boolean = this.canDrag();\n    const hasEventListeners: boolean =\n      Object.keys(this.eventListenerSubscriptions).length > 0;\n\n    if (canDrag && !hasEventListeners) {\n      this.zone.runOutsideAngular(() => {\n        this.eventListenerSubscriptions.mousedown = this.renderer.listen(\n          this.element.nativeElement,\n          'mousedown',\n          (event: MouseEvent) => {\n            this.onMouseDown(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.mouseup = this.renderer.listen(\n          'document',\n          'mouseup',\n          (event: MouseEvent) => {\n            this.onMouseUp(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.touchstart = this.renderer.listen(\n          this.element.nativeElement,\n          'touchstart',\n          (event: TouchEvent) => {\n            this.onTouchStart(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.touchend = this.renderer.listen(\n          'document',\n          'touchend',\n          (event: TouchEvent) => {\n            this.onTouchEnd(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.touchcancel = this.renderer.listen(\n          'document',\n          'touchcancel',\n          (event: TouchEvent) => {\n            this.onTouchEnd(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.mouseenter = this.renderer.listen(\n          this.element.nativeElement,\n          'mouseenter',\n          () => {\n            this.onMouseEnter();\n          }\n        );\n\n        this.eventListenerSubscriptions.mouseleave = this.renderer.listen(\n          this.element.nativeElement,\n          'mouseleave',\n          () => {\n            this.onMouseLeave();\n          }\n        );\n      });\n    } else if (!canDrag && hasEventListeners) {\n      this.unsubscribeEventListeners();\n    }\n  }\n\n  private onMouseDown(event: MouseEvent): void {\n    if (!this.eventListenerSubscriptions.mousemove) {\n      this.eventListenerSubscriptions.mousemove = this.renderer.listen(\n        'document',\n        'mousemove',\n        (mouseMoveEvent: MouseEvent) => {\n          this.pointerMove.next({\n            event: mouseMoveEvent,\n            clientX: mouseMoveEvent.clientX,\n            clientY: mouseMoveEvent.clientY\n          });\n        }\n      );\n    }\n    this.pointerDown.next({\n      event,\n      clientX: event.clientX,\n      clientY: event.clientY\n    });\n  }\n\n  private onMouseUp(event: MouseEvent): void {\n    if (this.eventListenerSubscriptions.mousemove) {\n      this.eventListenerSubscriptions.mousemove();\n      delete this.eventListenerSubscriptions.mousemove;\n    }\n    this.pointerUp.next({\n      event,\n      clientX: event.clientX,\n      clientY: event.clientY\n    });\n  }\n\n  private onTouchStart(event: TouchEvent): void {\n    if (!this.eventListenerSubscriptions.touchmove) {\n      this.eventListenerSubscriptions.touchmove = this.renderer.listen(\n        'document',\n        'touchmove',\n        (touchMoveEvent: TouchEvent) => {\n          this.pointerMove.next({\n            event: touchMoveEvent,\n            clientX: touchMoveEvent.targetTouches[0].clientX,\n            clientY: touchMoveEvent.targetTouches[0].clientY\n          });\n        }\n      );\n    }\n    this.pointerDown.next({\n      event,\n      clientX: event.touches[0].clientX,\n      clientY: event.touches[0].clientY\n    });\n  }\n\n  private onTouchEnd(event: TouchEvent): void {\n    if (this.eventListenerSubscriptions.touchmove) {\n      this.eventListenerSubscriptions.touchmove();\n      delete this.eventListenerSubscriptions.touchmove;\n    }\n    this.pointerUp.next({\n      event,\n      clientX: event.changedTouches[0].clientX,\n      clientY: event.changedTouches[0].clientY\n    });\n  }\n\n  private onMouseEnter(): void {\n    this.setCursor(this.dragCursor);\n  }\n\n  private onMouseLeave(): void {\n    this.setCursor('');\n  }\n\n  private setCssTransform(value: string): void {\n    if (this.ghostDragEnabled) {\n      const transformAttributes = [\n        'transform',\n        '-webkit-transform',\n        '-ms-transform',\n        '-moz-transform',\n        '-o-transform'\n      ];\n      transformAttributes.forEach(transformAttribute => {\n        this.renderer.setStyle(\n          this.element.nativeElement,\n          transformAttribute,\n          value\n        );\n      });\n    }\n  }\n\n  private canDrag(): boolean {\n    return this.dragAxis.x || this.dragAxis.y;\n  }\n\n  private setCursor(value: string): void {\n    this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n  }\n\n  private unsubscribeEventListeners(): void {\n    Object.keys(this.eventListenerSubscriptions).forEach(type => {\n      (this as any).eventListenerSubscriptions[type]();\n      delete (this as any).eventListenerSubscriptions[type];\n    });\n  }\n}\n","import {\n  Directive,\n  OnInit,\n  ElementRef,\n  OnDestroy,\n  Output,\n  EventEmitter,\n  NgZone\n} from '@angular/core';\nimport { Subject, Subscription } from 'rxjs';\nimport {\n  distinctUntilChanged,\n  pairwise,\n  filter,\n  map,\n  mergeMap\n} from 'rxjs/operators';\nimport { DraggableHelper } from './draggable-helper.provider';\n\nfunction isCoordinateWithinRectangle(\n  clientX: number,\n  clientY: number,\n  rect: ClientRect\n): boolean {\n  return (\n    clientX >= rect.left &&\n    clientX <= rect.right &&\n    clientY >= rect.top &&\n    clientY <= rect.bottom\n  );\n}\n\nexport interface DropData {\n  dropData: any;\n}\n\n@Directive({\n  selector: '[mwlDroppable]'\n})\nexport class DroppableDirective implements OnInit, OnDestroy {\n  /**\n   * Called when a draggable element starts overlapping the element\n   */\n  @Output() dragEnter = new EventEmitter<DropData>();\n\n  /**\n   * Called when a draggable element stops overlapping the element\n   */\n  @Output() dragLeave = new EventEmitter<DropData>();\n\n  /**\n   * Called when a draggable element is moved over the element\n   */\n  @Output() dragOver = new EventEmitter<DropData>();\n\n  /**\n   * Called when a draggable element is dropped on this element\n   */\n  @Output() drop = new EventEmitter<DropData>();\n\n  currentDragSubscription: Subscription;\n\n  constructor(\n    private element: ElementRef,\n    private draggableHelper: DraggableHelper,\n    private zone: NgZone\n  ) {}\n\n  ngOnInit(): void {\n    interface CurrentDragData {\n      clientX: number;\n      clientY: number;\n      dropData: any;\n    }\n\n    this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe(\n      (drag: Subject<CurrentDragData>) => {\n        const droppableRectangle: ClientRect = this.element.nativeElement.getBoundingClientRect();\n\n        let currentDragDropData: any;\n        const overlaps = drag.pipe(\n          map(({ clientX, clientY, dropData }) => {\n            currentDragDropData = dropData;\n            return isCoordinateWithinRectangle(\n              clientX,\n              clientY,\n              droppableRectangle\n            );\n          })\n        );\n\n        const overlapsChanged = overlaps.pipe(distinctUntilChanged());\n\n        let dragOverActive: boolean; // TODO - see if there's a way of doing this via rxjs\n\n        overlapsChanged\n          .pipe(filter(overlapsNow => overlapsNow))\n          .subscribe(() => {\n            dragOverActive = true;\n            this.zone.run(() => {\n              this.dragEnter.next({\n                dropData: currentDragDropData\n              });\n            });\n          });\n\n        overlaps.pipe(filter(overlapsNow => overlapsNow)).subscribe(() => {\n          this.zone.run(() => {\n            this.dragOver.next({\n              dropData: currentDragDropData\n            });\n          });\n        });\n\n        overlapsChanged\n          .pipe(pairwise())\n          .pipe(\n            filter(([didOverlap, overlapsNow]) => didOverlap && !overlapsNow)\n          )\n          .subscribe(() => {\n            dragOverActive = false;\n            this.zone.run(() => {\n              this.dragLeave.next({\n                dropData: currentDragDropData\n              });\n            });\n          });\n\n        drag.pipe(mergeMap(() => overlaps)).subscribe({\n          complete: () => {\n            if (dragOverActive) {\n              this.zone.run(() => {\n                this.drop.next({\n                  dropData: currentDragDropData\n                });\n              });\n            }\n          }\n        });\n      }\n    );\n  }\n\n  ngOnDestroy(): void {\n    this.currentDragSubscription.unsubscribe();\n  }\n}\n","import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { DraggableDirective } from './draggable.directive';\nimport { DroppableDirective } from './droppable.directive';\nimport { DraggableHelper } from './draggable-helper.provider';\n\n@NgModule({\n  declarations: [DraggableDirective, DroppableDirective],\n  exports: [DraggableDirective, DroppableDirective]\n})\nexport class DragAndDropModule {\n  static forRoot(): ModuleWithProviders {\n    return {\n      ngModule: DragAndDropModule,\n      providers: [DraggableHelper]\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}